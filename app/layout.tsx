import './globals.css'
import type { Metadata } from 'next'
import { Inter, Roboto } from 'next/font/google'
import localFont from 'next/font/local'
import NavBar from './NavBar'
import AuthProvider from './auth/provider'
import GoogleAnalyticsScript from './GoogleAnalyticsScript'
// import Script from 'next/script'

const inter = Inter({ subsets: ['latin'] })


//this is a function and we pass it an options object and it returns an 'object' and this object has a property named className that we need in Layout
//we reduce it to only the characters we need(like Latin, if we want to use latin lang)

const roboto = Roboto({   
  subsets: ['latin'],
  weight: ['400', '500']   //thickness of the font
})   //if we see in dev tools to filer fonts, our app is downloading two files for Roboto and 1 for inter b/c for roboto we ask for 2 weights
//but those fonts, even tho they are google fonts, they are served from our domain(next js)
//so the browser is not sending a separate request to google...when we build our app for production, next js automatically downloads these files from google and serves it with our app
//if we use variable fonts(like opensans), we don't need to provide weights

const poppins = localFont({  //for custom fonts
  src: '../public/fonts/poppins-regular-webfont.woff2' ,  //here we have to download the font first and add it to the public folder
  variable: '--font-poppins'     //assign it to custom css proprty that 'represents' our font
})
//to use custom fonts with tailwind, we go to tailwind configuration file, register a custom font and assign it to the above custom css property

export const metadata: Metadata = {    //metadata object
  title: 'Create Next App',
  description: 'Generated by create next app',
  openGraph: {  //this is used when we share our pages on social media platforms
    title: '...',
    description: '...'
  }
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" data-theme="winter">
      {/* <Script src="https://www.googletagmanager.com/gtag/js?id=GA_MEASUREMENT_ID" />
      <Script id="google-analytics" strategy='beforeInteractive'>
        {`
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
 
          gtag('config', 'GA_MEASUREMENT_ID');
        `}
      </Script> */}

      <GoogleAnalyticsScript />
      <body className={poppins.variable}> 
        <AuthProvider>  
        <NavBar />
        <main className='p-5 '> {children} </main>
        </AuthProvider>
      </body>
      
    </html>
  )
} 

//{children} can be any of the pages

// {` `} - to wrap the long string and pass it as a child the Script component and the Script comp will parse these string and interpret it as a javascript code
//instead of the script tag, we have to use the script component in next js
//dataLayer is a global object
//most of the errors and issued by the typescript compiler
//if the strategy is set to 'beforeInteractive', the script is loaded before next js injects any client side code to our pages(it is called hydration)
//Generally server comps are rendered on the server and return to the client and then next js renders and injects client side code on our pages(hydration)
//afterInteractive(the default) - wsith this our scripts are loaded after our page becomes interactive(after the injection of client side code like event handling)
//lazyOnload - with this strategy, our scripts are loaded after all the resources on the page has been fetched